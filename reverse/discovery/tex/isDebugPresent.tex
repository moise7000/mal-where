\documentclass[11pt,a4paper]{article}

% Packages de base
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[margin=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{fancyhdr}

% Importer le template malware 
\usepackage{malware-template}

% Configuration en-tête/pied de page
\pagestyle{fancy}
\fancyhf{}
\lhead{Analyse Reverse Engineering}
\rhead{\thepage}
\lfoot{Garance Frolla}
\rfoot{\today}
\setlength{\headheight}{14pt}

\begin{document}



    \discoverystart
    {Détection Manuelle du Débogueur (PEB)}
    {0x004044DF}
    {sub\_4044B0}
    {Anti-debug / Evasion}
    {High}

    \subsubsection*{Code Assembleur}
    \begin{asmcode}
; Acces manuel au TEB puis au PEB pour verifier le flag BeingDebugged
mov     ebx, 28h
mov     ecx, 2
mov     eax, fs:[ebx+ecx*4]   ; EAX = Adresse du PEB (FS:[30h])
mov     edx, eax
cmp     byte ptr [edx+2], 0   ; Verifie l'offset +2 (BeingDebugged)
jnz     loc_4045F0            ; Saute vers la sortie d'echec si detecte
    \end{asmcode}

    \subsubsection*{Code Décompilé (Reconstitution)}
    \begin{ccode}
// Verification combinee API et acces direct memoire
CheckRemoteDebuggerPresent(GetCurrentProcess(), &pbDebuggerPresent);

// Lecture directe du segment FS
PEB* peb = (PEB*)__readfsdword(0x30);
if (peb->BeingDebugged == 1) {
    return 0; // Echec silencieux
}
    \end{ccode}

    \discoveryanalysis{%
        Le binaire utilise une technique d'anti-débogage classique mais obfusquée par des calculs d'index sur le segment FS. Il récupère l'adresse du \textbf{Process Environment Block (PEB)} à l'adresse \texttt{FS:[0x30]} et vérifie le champ \texttt{BeingDebugged} (offset 0x02).
        Si ce champ est à 1 (présence d'un débogueur), le programme branche vers \texttt{loc\_4045F0}, qui nettoie la pile et retourne 0, empêchant l'exécution de la logique de décodage.
    }

    \discoveryend


\end{document}
